{"ast":null,"code":"import { JEWEL_COUNT } from './jewels';\nimport { throwMissingParam, createMatrix, makeGenerateRandomIntInclusive, mutatePropsInObjectMatrix, extractPropFromObjectMatrix } from '../utils/utils';\nexport const BOARD_WIDTH = 8;\nexport const BOARD_HEIGHT = 8;\nexport const extractJewelIndexFrom = extractPropFromObjectMatrix('jewelIndex');\nexport const generateJewelIndex = makeGenerateRandomIntInclusive(0, JEWEL_COUNT - 1);\nexport const mutateJewelIndexOf = mutatePropsInObjectMatrix('jewelIndex');\n\nconst makeBoardField = _ref => {\n  let {\n    jewelIndex = generateJewelIndex(),\n    x = throwMissingParam('x'),\n    y = throwMissingParam('y'),\n    up = null,\n    down = null,\n    left = null,\n    right = null\n  } = _ref;\n  return Object.seal({\n    jewelIndex,\n    x,\n    y,\n    up,\n    down,\n    left,\n    right\n  });\n};\n\nexport const makeBoard = function () {\n  let xLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : BOARD_WIDTH;\n  let yLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BOARD_HEIGHT;\n  const matrix = createMatrix(xLength, yLength);\n  matrix.forEach((xArray, x) => xArray.forEach((yField, y) => {\n    const currentField = matrix[x][y] = makeBoardField({\n      x: x,\n      y: y,\n      left: x === 0 ? null : matrix[x - 1][y],\n      down: y === 0 ? null : matrix[x][y - 1]\n    });\n    if (currentField.down) currentField.down.up = currentField;\n    if (currentField.left) currentField.left.right = currentField;\n  }));\n  return matrix;\n};\nexport const createNullifiedCombosMatrix = comboMatrix => matrix => {\n  const nullifiedCombosMatrix = matrix.map((column, columnIndex) => column.map((row, rowIndex) => comboMatrix[columnIndex] ? !comboMatrix[columnIndex][rowIndex] ? row : null : matrix[columnIndex][rowIndex]));\n  return nullifiedCombosMatrix;\n};\nexport const createNullShiftedMatrix = matrix => matrix.map(xArray => [...xArray].sort((a, b) => a === null ? 1 : b === null ? -1 : 0));\nexport const createNullFilledMatrix = fillFn => matrix => matrix.map(xArray => xArray.map(yField => yField !== null ? yField : fillFn()));\nexport const createTwoFieldSwappedMatrix = _ref2 => {\n  let {\n    x: x1,\n    y: y1\n  } = _ref2;\n  return _ref3 => {\n    let {\n      x: x2,\n      y: y2\n    } = _ref3;\n    return matrix => {\n      const newMatrix = JSON.parse(JSON.stringify(matrix));\n      [newMatrix[x1][y1], newMatrix[x2][y2]] = [newMatrix[x2][y2], newMatrix[x1][y1]];\n      return newMatrix;\n    };\n  };\n};\n/* eslint-disable no-cond-assign */\n\nconst getCombosInLinkedList = directionLink => startField => {\n  const coordinate = {\n    right: 'x',\n    up: 'y'\n  }[directionLink];\n  let currentField = startField;\n  let latestCombo = [];\n  let sumOfCombos = [];\n\n  do {\n    if (latestCombo.length && currentField.jewelIndex !== latestCombo[latestCombo.length - 1].jewelIndex) {\n      if (latestCombo.length >= 3) sumOfCombos.push(...latestCombo.map(field => field[coordinate]));\n      latestCombo = [];\n    }\n\n    latestCombo.push(currentField);\n  } while (currentField = currentField[directionLink]);\n\n  if (latestCombo.length >= 3) sumOfCombos.push(...latestCombo.map(field => field[coordinate]));\n  return sumOfCombos;\n};\n\nconst traverseRightAndFindCombos = getCombosInLinkedList('right');\nconst traverseUpAndFindCombos = getCombosInLinkedList('up');\nexport const traverseAndFindCombos = board => {\n  const comboMap = {\n    x: [],\n    y: []\n  };\n  const zeroRow = board.map(column => column[0]);\n  comboMap.x = zeroRow.map(traverseUpAndFindCombos);\n  const zeroColumn = board[0];\n  comboMap.y = zeroColumn.map(traverseRightAndFindCombos);\n  return comboMap;\n};\nexport const traverseAndFindCombo = field => {\n  const partialComboMap = {\n    x: [],\n    y: []\n  };\n\n  const travelLeft = field => field.left ? travelLeft(field.left) : field;\n\n  const farLeftField = travelLeft(field);\n  partialComboMap.y[field.y] = traverseRightAndFindCombos(farLeftField);\n\n  const travelDown = field => field.down ? travelDown(field.down) : field;\n\n  const bottomField = travelDown(field);\n  partialComboMap.x[field.x] = traverseUpAndFindCombos(bottomField);\n  return partialComboMap;\n};\nexport const generateComboMatrixFromCombos = comboMap => {\n  const comboMatrix = createMatrix(comboMap.x.length, comboMap.y.length);\n  comboMap.x.forEach((column, columnIndex) => column.forEach(rowIndex => comboMatrix[columnIndex][rowIndex] = true));\n  comboMap.y.forEach((row, rowIndex) => row.forEach(columnIndex => comboMatrix[columnIndex][rowIndex] = true));\n  return comboMatrix;\n};\nexport const getPotentialCombosInLinkedList = direction => startField => {\n  const oppositeDirection = {\n    right: 'left',\n    up: 'down'\n  }[direction];\n  const orthogonalDirections = {\n    right: ['up', 'down'],\n    up: ['left', 'right']\n  }[direction];\n  const potentialCombos = [];\n\n  if (startField[direction] && startField[direction][direction] && startField[direction].jewelIndex === startField[direction][direction].jewelIndex) {\n    const potentialComboJewel = startField[direction].jewelIndex;\n    orthogonalDirections.forEach(orthDir => {\n      if (startField[orthDir] && startField[orthDir].jewelIndex === potentialComboJewel) {\n        potentialCombos.push({\n          x2: startField[orthDir].x,\n          y2: startField[orthDir].y\n        });\n      }\n    });\n\n    if (startField[oppositeDirection] && startField[oppositeDirection].jewelIndex === potentialComboJewel) {\n      potentialCombos.push({\n        x2: startField[oppositeDirection].x,\n        y2: startField[oppositeDirection].y\n      });\n    }\n  }\n\n  if (startField[oppositeDirection] && startField[direction] && startField[oppositeDirection].jewelIndex === startField[direction].jewelIndex) {\n    const potentialComboJewel = startField[direction].jewelIndex;\n    orthogonalDirections.forEach(orthDir => {\n      if (startField[orthDir] && startField[orthDir].jewelIndex === potentialComboJewel) {\n        potentialCombos.push({\n          x2: startField[orthDir].x,\n          y2: startField[orthDir].y\n        });\n      }\n    });\n  }\n\n  if (startField[oppositeDirection] && startField[oppositeDirection][oppositeDirection] && startField[oppositeDirection].jewelIndex === startField[oppositeDirection][oppositeDirection].jewelIndex) {\n    const potentialComboJewel = startField[oppositeDirection].jewelIndex;\n    orthogonalDirections.forEach(orthDir => {\n      if (startField[orthDir] && startField[orthDir].jewelIndex === potentialComboJewel) {\n        potentialCombos.push({\n          x2: startField[orthDir].x,\n          y2: startField[orthDir].y\n        });\n      }\n    });\n\n    if (startField[direction] && startField[direction].jewelIndex === potentialComboJewel) {\n      potentialCombos.push({\n        x2: startField[direction].x,\n        y2: startField[direction].y\n      });\n    }\n  }\n\n  return potentialCombos.map(endField => ({\n    x1: startField.x,\n    y1: startField.y,\n    ...endField\n  }));\n};\nconst traverseRightAndFindPotentialCombos = getPotentialCombosInLinkedList('right');\nconst traverseUpAndFindPotentialCombos = getPotentialCombosInLinkedList('up');\nexport const traverseAndFindPotentialCombos = board => {\n  const potentialCombosNested = board.map((xArray, x) => xArray.map((yField, y) => [...traverseUpAndFindPotentialCombos(yField), ...traverseRightAndFindPotentialCombos(yField)]));\n  return potentialCombosNested.reduce((flatArr, potentialComboArr) => [...flatArr, ...potentialComboArr], []).filter(fieldPotentialCombos => fieldPotentialCombos.length);\n};\nexport const internals = {\n  generateJewelIndex,\n  makeBoardField,\n  makeBoard,\n  createNullifiedCombosMatrix,\n  createNullShiftedMatrix,\n  createNullFilledMatrix,\n  createTwoFieldSwappedMatrix,\n  getCombosInLinkedList,\n  traverseRightAndFindCombos,\n  traverseUpAndFindCombos,\n  traverseAndFindCombos,\n  traverseAndFindCombo,\n  generateComboMatrixFromCombos,\n  getPotentialCombosInLinkedList,\n  traverseAndFindPotentialCombos\n};","map":{"version":3,"sources":["C:/Users/17144/gametest/src/App/engine/board.js"],"names":["JEWEL_COUNT","throwMissingParam","createMatrix","makeGenerateRandomIntInclusive","mutatePropsInObjectMatrix","extractPropFromObjectMatrix","BOARD_WIDTH","BOARD_HEIGHT","extractJewelIndexFrom","generateJewelIndex","mutateJewelIndexOf","makeBoardField","jewelIndex","x","y","up","down","left","right","Object","seal","makeBoard","xLength","yLength","matrix","forEach","xArray","yField","currentField","createNullifiedCombosMatrix","comboMatrix","nullifiedCombosMatrix","map","column","columnIndex","row","rowIndex","createNullShiftedMatrix","sort","a","b","createNullFilledMatrix","fillFn","createTwoFieldSwappedMatrix","x1","y1","x2","y2","newMatrix","JSON","parse","stringify","getCombosInLinkedList","directionLink","startField","coordinate","latestCombo","sumOfCombos","length","push","field","traverseRightAndFindCombos","traverseUpAndFindCombos","traverseAndFindCombos","board","comboMap","zeroRow","zeroColumn","traverseAndFindCombo","partialComboMap","travelLeft","farLeftField","travelDown","bottomField","generateComboMatrixFromCombos","getPotentialCombosInLinkedList","direction","oppositeDirection","orthogonalDirections","potentialCombos","potentialComboJewel","orthDir","endField","traverseRightAndFindPotentialCombos","traverseUpAndFindPotentialCombos","traverseAndFindPotentialCombos","potentialCombosNested","reduce","flatArr","potentialComboArr","filter","fieldPotentialCombos","internals"],"mappings":"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","sourcesContent":["import { JEWEL_COUNT } from './jewels';\r\nimport {\r\n    throwMissingParam,\r\n    createMatrix,\r\n    makeGenerateRandomIntInclusive,\r\n    mutatePropsInObjectMatrix,\r\n    extractPropFromObjectMatrix\r\n} from '../utils/utils';\r\n\r\nexport const BOARD_WIDTH = 8;\r\nexport const BOARD_HEIGHT = 8;\r\n\r\nexport const extractJewelIndexFrom = extractPropFromObjectMatrix('jewelIndex');\r\nexport const generateJewelIndex = makeGenerateRandomIntInclusive(0, JEWEL_COUNT - 1);\r\nexport const mutateJewelIndexOf = mutatePropsInObjectMatrix('jewelIndex');\r\n\r\nconst makeBoardField = ({\r\n    jewelIndex = generateJewelIndex(),\r\n    x = throwMissingParam('x'),\r\n    y = throwMissingParam('y'),\r\n    up = null,\r\n    down = null,\r\n    left = null,\r\n    right = null\r\n}) => Object.seal({\r\n    jewelIndex, x, y, up, down, left, right\r\n});\r\n\r\nexport const makeBoard = (xLength = BOARD_WIDTH, yLength = BOARD_HEIGHT) => {\r\n\r\n    const matrix = createMatrix(xLength, yLength);\r\n\r\n    matrix.forEach((xArray, x) =>\r\n        xArray.forEach((yField, y) => {\r\n\r\n            const currentField = matrix[x][y] = makeBoardField({\r\n                x: x,\r\n                y: y,\r\n                left: x === 0 ? null : matrix[x - 1][y],\r\n                down: y === 0 ? null : matrix[x][y - 1]\r\n            });\r\n\r\n            if (currentField.down) currentField.down.up = currentField;\r\n            if (currentField.left) currentField.left.right = currentField;\r\n        })\r\n    );\r\n\r\n    return matrix;\r\n};\r\n\r\nexport const createNullifiedCombosMatrix = comboMatrix => matrix => {\r\n\r\n    const nullifiedCombosMatrix = matrix.map((column, columnIndex) =>\r\n        column.map((row, rowIndex) =>\r\n            comboMatrix[columnIndex]\r\n                ? !comboMatrix[columnIndex][rowIndex] ? row : null\r\n                : matrix[columnIndex][rowIndex]\r\n        )\r\n    );\r\n\r\n    return nullifiedCombosMatrix;\r\n};\r\n\r\nexport const createNullShiftedMatrix = matrix => matrix.map(xArray =>\r\n    [...xArray].sort((a, b) => a === null ? 1 : (b === null ? -1 : 0))\r\n);\r\n\r\nexport const createNullFilledMatrix = fillFn => matrix => matrix.map(xArray =>\r\n    xArray.map(yField => yField !== null ? yField : fillFn())\r\n);\r\n\r\nexport const createTwoFieldSwappedMatrix = ({ x: x1, y: y1 }) => ({ x: x2, y: y2 }) => matrix => {\r\n\r\n    const newMatrix = JSON.parse(JSON.stringify(matrix));\r\n    [newMatrix[x1][y1], newMatrix[x2][y2]] = [newMatrix[x2][y2], newMatrix[x1][y1]];\r\n\r\n    return newMatrix;\r\n}\r\n\r\n/* eslint-disable no-cond-assign */\r\nconst getCombosInLinkedList = directionLink =>\r\n    startField => {\r\n\r\n        const coordinate = { right: 'x', up: 'y' }[directionLink];\r\n        let currentField = startField;\r\n        let latestCombo = [];\r\n        let sumOfCombos = [];\r\n\r\n        do {\r\n            if (latestCombo.length && currentField.jewelIndex !== latestCombo[latestCombo.length - 1].jewelIndex) {\r\n                if (latestCombo.length >= 3) sumOfCombos.push(...latestCombo.map(field => field[coordinate]));\r\n                latestCombo = [];\r\n            }\r\n            latestCombo.push(currentField);\r\n        } while (currentField = currentField[directionLink]);\r\n        if (latestCombo.length >= 3) sumOfCombos.push(...latestCombo.map(field => field[coordinate]));\r\n\r\n        return sumOfCombos;\r\n    };\r\n\r\nconst traverseRightAndFindCombos = getCombosInLinkedList('right');\r\nconst traverseUpAndFindCombos = getCombosInLinkedList('up');\r\n\r\nexport const traverseAndFindCombos = board => {\r\n\r\n    const comboMap = { x: [], y: [] };\r\n\r\n    const zeroRow = board.map(column => column[0]);\r\n    comboMap.x = zeroRow.map(traverseUpAndFindCombos);\r\n\r\n    const zeroColumn = board[0];\r\n    comboMap.y = zeroColumn.map(traverseRightAndFindCombos);\r\n\r\n    return comboMap;\r\n};\r\n\r\nexport const traverseAndFindCombo = field => {\r\n\r\n    const partialComboMap = { x: [], y: [] };\r\n\r\n    const travelLeft = (field) => field.left ? travelLeft(field.left) : field;\r\n    const farLeftField = travelLeft(field);\r\n    partialComboMap.y[field.y] = traverseRightAndFindCombos(farLeftField);\r\n\r\n    const travelDown = (field) => field.down ? travelDown(field.down) : field;\r\n    const bottomField = travelDown(field);\r\n    partialComboMap.x[field.x] = traverseUpAndFindCombos(bottomField);\r\n\r\n    return partialComboMap;\r\n};\r\n\r\nexport const generateComboMatrixFromCombos = comboMap => {\r\n    const comboMatrix = createMatrix(comboMap.x.length, comboMap.y.length);\r\n\r\n    comboMap.x.forEach((column, columnIndex) =>\r\n        column.forEach(rowIndex => comboMatrix[columnIndex][rowIndex] = true)\r\n    );\r\n    comboMap.y.forEach((row, rowIndex) =>\r\n        row.forEach(columnIndex => comboMatrix[columnIndex][rowIndex] = true)\r\n    );\r\n\r\n    return comboMatrix;\r\n}\r\n\r\nexport const getPotentialCombosInLinkedList = direction =>\r\n    startField => {\r\n\r\n        const oppositeDirection = { right: 'left', up: 'down' }[direction];\r\n        const orthogonalDirections = { right: ['up', 'down'], up: ['left', 'right']}[direction];\r\n        const potentialCombos = [];\r\n\r\n        if (\r\n            startField[direction] && startField[direction][direction]\r\n            && startField[direction].jewelIndex === startField[direction][direction].jewelIndex\r\n        ) {\r\n            const potentialComboJewel = startField[direction].jewelIndex;\r\n            orthogonalDirections.forEach(orthDir => {\r\n                if (startField[orthDir] && startField[orthDir].jewelIndex === potentialComboJewel) {\r\n                    potentialCombos.push({ x2: startField[orthDir].x, y2: startField[orthDir].y });\r\n                }\r\n            });\r\n            if (startField[oppositeDirection] && startField[oppositeDirection].jewelIndex === potentialComboJewel) {\r\n                potentialCombos.push({ x2: startField[oppositeDirection].x, y2: startField[oppositeDirection].y });\r\n            }\r\n        }\r\n\r\n        if (\r\n            startField[oppositeDirection] && startField[direction]\r\n            && startField[oppositeDirection].jewelIndex === startField[direction].jewelIndex\r\n        ) {\r\n            const potentialComboJewel = startField[direction].jewelIndex;\r\n            orthogonalDirections.forEach(orthDir => {\r\n                if (startField[orthDir] && startField[orthDir].jewelIndex === potentialComboJewel) {\r\n                    potentialCombos.push({ x2: startField[orthDir].x, y2: startField[orthDir].y });\r\n                }\r\n            });\r\n        }\r\n\r\n        if (\r\n            startField[oppositeDirection] && startField[oppositeDirection][oppositeDirection]\r\n            && startField[oppositeDirection].jewelIndex === startField[oppositeDirection][oppositeDirection].jewelIndex\r\n        ) {\r\n            const potentialComboJewel = startField[oppositeDirection].jewelIndex;\r\n            orthogonalDirections.forEach(orthDir => {\r\n                if (startField[orthDir] && startField[orthDir].jewelIndex === potentialComboJewel) {\r\n                    potentialCombos.push({ x2: startField[orthDir].x, y2: startField[orthDir].y });\r\n                }\r\n            });\r\n            if (startField[direction] && startField[direction].jewelIndex === potentialComboJewel) {\r\n                potentialCombos.push({ x2: startField[direction].x, y2: startField[direction].y });\r\n            }\r\n        }\r\n\r\n        return potentialCombos.map(endField => ({ x1: startField.x, y1: startField.y, ...endField }));\r\n    };\r\n\r\nconst traverseRightAndFindPotentialCombos = getPotentialCombosInLinkedList('right');\r\nconst traverseUpAndFindPotentialCombos = getPotentialCombosInLinkedList('up');\r\n\r\nexport const traverseAndFindPotentialCombos = board => {\r\n\r\n    const potentialCombosNested = board.map((xArray, x) =>\r\n        xArray.map((yField, y) =>\r\n            [...traverseUpAndFindPotentialCombos(yField), ...traverseRightAndFindPotentialCombos(yField)]\r\n        )\r\n    );\r\n    return potentialCombosNested\r\n        .reduce((flatArr, potentialComboArr) => [...flatArr, ...potentialComboArr], [])\r\n        .filter(fieldPotentialCombos => fieldPotentialCombos.length);\r\n};\r\n\r\nexport const internals = {\r\n    generateJewelIndex,\r\n    makeBoardField,\r\n    makeBoard,\r\n    createNullifiedCombosMatrix,\r\n    createNullShiftedMatrix,\r\n    createNullFilledMatrix,\r\n    createTwoFieldSwappedMatrix,\r\n    getCombosInLinkedList,\r\n    traverseRightAndFindCombos,\r\n    traverseUpAndFindCombos,\r\n    traverseAndFindCombos,\r\n    traverseAndFindCombo,\r\n    generateComboMatrixFromCombos,\r\n    getPotentialCombosInLinkedList,\r\n    traverseAndFindPotentialCombos\r\n};\r\n"]},"metadata":{},"sourceType":"module"}